# Анализ: Структуризация префиксов типов узлов

**Дата**: 2025-11-05  
**Вопрос**: Нужна ли замена `c:` на `a:c:` (добавление префикса сегмента)?

---

## Текущая структура

**Префиксы**:
- `c:` → concept (архитектура)
- `t:` → technology (архитектура)
- `v:` → version (архитектура)
- `d:` → directory (файловая система)
- `m:` → module (код)
- `comp:` → component (код)
- `f:` → file (файловая система)
- `cl:` → class (код)
- `cln:` → nested-class (код)

**Примеры ключей**:
- `c:project`
- `t:python`
- `d:src/lib`
- `m:graph_viewer`

---

## Предлагаемая структура

**Префиксы с сегментами**:
- `a:c:` → architecture:concept
- `a:t:` → architecture:technology
- `a:v:` → architecture:version
- `f:d:` → filesystem:directory
- `f:file:` → filesystem:file
- `c:m:` → code:module
- `c:comp:` → code:component
- `c:cl:` → code:class
- `c:cln:` → code:nested-class

**Примеры ключей**:
- `a:c:project`
- `a:t:python`
- `f:d:src/lib`
- `c:m:graph_viewer`

---

## Сравнение подходов

### Преимущества структуризации (`a:c:`)

✅ **Явная структура**: Сегмент виден в ключе  
✅ **Самодокументируемость**: По ключу понятно, что это архитектура  
✅ **Группировка**: Легче фильтровать по сегментам  
✅ **Расширяемость**: Легче добавить новые сегменты  
✅ **Валидация**: Можно проверить соответствие сегмента и типа  

### Недостатки структуризации

❌ **Длиннее ключи**: `a:c:project` вместо `c:project` (+2 символа)  
❌ **Миграция**: Нужно переименовать все существующие ключи  
❌ **Избыточность**: Сегмент можно определить по типу (`c:` → architecture)  
❌ **Сложнее**: Больше символов для ввода  

---

## Анализ использования

### 1. Определение типа по ключу

**Текущий подход**:
```javascript
if (key.startsWith('c:')) return 'concept'
if (key.startsWith('t:')) return 'technology'
```

**Структурированный подход**:
```javascript
if (key.startsWith('a:c:')) return 'concept'
if (key.startsWith('a:t:')) return 'technology'
```

**Вывод**: Оба подхода просты, но структурированный длиннее.

### 2. Определение сегмента

**Текущий подход**:
```javascript
function getSegment(nodeType) {
  if (['concept', 'technology', 'version'].includes(nodeType)) return 'architecture'
  if (['module', 'component', 'class'].includes(nodeType)) return 'code_structure'
  // ...
}
```

**Структурированный подход**:
```javascript
function getSegment(key) {
  if (key.startsWith('a:')) return 'architecture'
  if (key.startsWith('c:')) return 'code_structure'
  if (key.startsWith('f:')) return 'filesystem'
}
```

**Вывод**: Структурированный подход проще для определения сегмента по ключу.

### 3. Валидация

**Текущий подход**:
```python
if node_type == 'concept' and not node_key.startswith('c:'):
    return False
```

**Структурированный подход**:
```python
if node_type == 'concept' and not node_key.startswith('a:c:'):
    return False
```

**Вывод**: Оба подхода аналогичны, но структурированный явнее.

### 4. Фильтрация по сегментам

**Текущий подход**:
```python
# Нужно знать все типы сегмента
if node_type in ['concept', 'technology', 'version']:
    # архитектура
```

**Структурированный подход**:
```python
# Просто по префиксу
if node_key.startswith('a:'):
    # архитектура
```

**Вывод**: Структурированный подход проще для фильтрации.

---

## Критерии оценки

### 1. Читаемость

**Текущий**: `c:project` — коротко, но неочевидно, что это архитектура  
**Структурированный**: `a:c:project` — длиннее, но явно видно сегмент  

**Вердикт**: Структурированный лучше для читаемости.

### 2. Простота использования

**Текущий**: Короче для ввода  
**Структурированный**: Длиннее, но понятнее  

**Вердикт**: Текущий проще для ввода.

### 3. Расширяемость

**Текущий**: При добавлении нового сегмента нужно помнить маппинг типов  
**Структурированный**: Новый сегмент = новый префикс, всё явно  

**Вердикт**: Структурированный лучше для расширяемости.

### 4. Производительность

**Текущий**: `startsWith('c:')` — быстрее  
**Структурированный**: `startsWith('a:c:')` — немного медленнее (незначительно)  

**Вердикт**: Разница незначительна.

### 5. Миграция

**Текущий**: Не нужна  
**Структурированный**: Нужна миграция всех ключей  

**Вердикт**: Текущий проще.

---

## Рекомендация

### ❌ **НЕ структурировать** префиксы

**Причины**:

1. **Избыточность**: Сегмент можно определить по типу узла через маппинг
2. **Длина ключей**: Уже есть проблема с длинными ключами для файлов/модулей
3. **Миграция**: Сложная и рискованная операция
4. **Простота**: Текущие префиксы короче и проще
5. **Достаточность**: Текущая система работает и понятна

### Альтернатива: Определение сегмента через маппинг

Вместо структуризации префиксов использовать маппинг:

```javascript
// Утилита определения сегмента
function getSegmentByType(nodeType) {
  const mapping = {
    'concept': 'architecture',
    'technology': 'architecture',
    'version': 'architecture',
    'module': 'code_structure',
    'component': 'code_structure',
    'class': 'code_structure',
    'nested-class': 'code_structure',
    'directory': 'filesystem',
    'file': 'filesystem'
  }
  return mapping[nodeType] || 'other'
}

// Или по ключу
function getSegmentByKey(key) {
  if (key.startsWith('c:') || key.startsWith('t:') || key.startsWith('v:')) {
    return 'architecture'
  }
  if (key.startsWith('m:') || key.startsWith('comp:') || key.startsWith('cl')) {
    return 'code_structure'
  }
  if (key.startsWith('d:') || key.startsWith('f:')) {
    return 'filesystem'
  }
  return 'other'
}
```

---

## Вывод

**Структуризация префиксов (`a:c:` вместо `c:`) не нужна**, потому что:

1. ✅ Сегмент можно определить через маппинг типов
2. ✅ Текущие префиксы короче и проще
3. ✅ Миграция сложна и рискованна
4. ✅ Текущая система работает и понятна
5. ✅ Избыточность не оправдана

**Рекомендация**: Оставить текущие префиксы (`c:`, `t:`, `v:`, `d:`, `m:`, `comp:`, `f:`, `cl:`, `cln:`) и определять сегмент через маппинг типов.

---

**Дата создания**: 2025-11-05  
**Автор**: Александр  
**Версия**: 1.0

