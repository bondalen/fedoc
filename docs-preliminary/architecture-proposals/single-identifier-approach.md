# Подход: Единый идентификатор узла

**Дата**: 2025-11-05  
**Статус**: Предложение  
**Приоритет**: Высокий

---

## Проблема

Текущая система использует два идентификатора для одного узла:
- `id` (12345) — внутренний числовой ID БД (AGE ID)
- `key` ("a.c.project") — уникальный строковый ключ

**Дублирование**: Оба идентификатора служат одной цели — уникально определить узел.

---

## Варианты решения

### Вариант 1: Только `id` (числовой)

**Структура узла**:
```json
{
  "id": 12345,
  "name": "Проект",
  "type": "a.c",  // тип для визуализации
  "properties": {...}
}
```

**Преимущества**:
- ✅ Компактность: числовой ID короче
- ✅ Производительность: числовые сравнения быстрее
- ✅ Индексация: числовые индексы эффективнее
- ✅ Рёбра: `from_id` и `to_id` уже числовые

**Недостатки**:
- ❌ Нет самодокументируемости: по ID не понятно, что это за узел
- ❌ Нужно хранить `type` отдельно
- ❌ Сложнее отладка: нужно смотреть в БД
- ❌ Нет человекочитаемости в логах/API

**Использование**:
```python
# Поиск узла
MATCH (n) WHERE id(n) = 12345

# Создание ребра
CREATE (a)-[e]->(b) WHERE id(a) = 12345 AND id(b) = 67890
```

---

### Вариант 2: Только `key` (строковый с типом)

**Структура узла**:
```json
{
  "key": "a.c.project",
  "name": "Проект",
  "properties": {...}
}
```

**Преимущества**:
- ✅ Самодокументируемость: по ключу понятно, что это за узел
- ✅ Тип в ключе: не нужно хранить отдельно
- ✅ Человекочитаемость: понятно в логах, API, отладке
- ✅ Уникальность: ключ сам по себе уникален
- ✅ Простота: один идентификатор вместо двух

**Недостатки**:
- ⚠️ Длиннее: строки длиннее чисел
- ⚠️ Производительность: строковые сравнения медленнее
- ⚠️ Рёбра: нужно переделать на строковые ключи

**Использование**:
```python
# Поиск узла
MATCH (n {key: 'a.c.project'})

# Создание ребра
CREATE (a)-[e]->(b) 
WHERE a.key = 'a.c.project' AND b.key = 'a.t.python'
```

---

## Сравнение подходов

| Аспект | Только `id` | Только `key` |
|--------|------------|--------------|
| **Размер данных** | Компактный (4-8 байт) | Длиннее (10-50 байт) |
| **Производительность** | ✅ Быстрее | ⚠️ Медленнее |
| **Читаемость** | ❌ Нечитаемо | ✅ Читаемо |
| **Тип узла** | ❌ Нужно отдельно | ✅ В ключе |
| **Отладка** | ❌ Сложнее | ✅ Проще |
| **Рёбра** | ✅ Уже числовые | ⚠️ Нужно переделать |
| **Индексация** | ✅ Эффективнее | ⚠️ Менее эффективна |
| **API** | ❌ Непонятно | ✅ Понятно |

---

## Рекомендация: Только `key`

**Почему**:
1. **Простота**: Один идентификатор вместо двух
2. **Самодокументируемость**: По ключу сразу понятно, что это за узел
3. **Тип в ключе**: Не нужно хранить `node_type` отдельно
4. **Человекочитаемость**: Удобно для отладки, логов, API
5. **Уникальность**: Ключ сам по себе уникален

**Производительность**: Для большинства случаев разница не критична, особенно с правильной индексацией.

---

## Реализация: Только `key`

### Структура узла в БД

```sql
-- Создание узла
CREATE (n:canonical_node {
    key: 'a.c.project',  -- первичный идентификатор
    name: 'Проект',
    properties: {...}
})
```

**Поля**:
- `key` — уникальный ключ (PRIMARY KEY или UNIQUE INDEX)
- `name` — отображаемое имя
- `properties` — дополнительные свойства

**Удалены**:
- ❌ `id` (внутренний AGE ID не используется как идентификатор)
- ❌ `node_type` (извлекается из `key`)

### Поиск узлов

**Старый подход**:
```python
# Нужно конвертировать key → id
node_id = convert_key_to_id('a.c.project')
MATCH (n) WHERE id(n) = {node_id}
```

**Новый подход**:
```python
# Прямой поиск по ключу
MATCH (n {key: 'a.c.project'})
```

### Рёбра

**Старый формат**:
```cypher
CREATE (a)-[e:project_relation]->(b)
WHERE id(a) = 12345 AND id(b) = 67890
```

**Новый формат**:
```cypher
CREATE (a)-[e:project_relation {
    from_key: 'a.c.project',
    to_key: 'a.t.python'
}]->(b)
WHERE a.key = 'a.c.project' AND b.key = 'a.t.python'
```

**Или использовать ключи в свойствах рёбер**:
```cypher
MATCH (a {key: 'a.c.project'}), (b {key: 'a.t.python'})
CREATE (a)-[e:project_relation {
    from_key: a.key,
    to_key: b.key,
    projects: ['fedoc']
}]->(b)
```

### Индексация

```sql
-- Создать уникальный индекс на key
CREATE UNIQUE INDEX idx_nodes_key ON vertices(key);

-- Или использовать key как PRIMARY KEY (если возможно в AGE)
```

---

## API изменения

### GET /api/nodes

**Старый ответ**:
```json
{
  "id": 12345,
  "key": "a.c.project",
  "name": "Проект",
  "node_type": "concept"
}
```

**Новый ответ**:
```json
{
  "key": "a.c.project",
  "name": "Проект"
}
```

### POST /api/nodes

**Старый запрос**:
```json
{
  "node_key": "a.c.project",
  "node_name": "Проект",
  "node_type": "concept"
}
```

**Новый запрос**:
```json
{
  "key": "a.c.project",
  "name": "Проект"
}
```

### GET /api/graph

**Старый формат рёбер**:
```json
{
  "id": 123,
  "from": 12345,
  "to": 67890,
  "from_key": "a.c.project",
  "to_key": "a.t.python"
}
```

**Новый формат рёбер**:
```json
{
  "id": 123,  // внутренний ID ребра (можно оставить для визуализации)
  "from": "a.c.project",
  "to": "a.t.python"
}
```

---

## Миграция рёбер

### Текущая структура рёбер

```cypher
MATCH (a)-[e]->(b)
RETURN id(e), id(a), id(b)
```

### Новая структура рёбер

```cypher
MATCH (a)-[e]->(b)
RETURN id(e), a.key as from, b.key as to
```

**Или хранить ключи в свойствах рёбер**:
```cypher
CREATE (a)-[e:project_relation {
    from_key: a.key,
    to_key: b.key,
    projects: ['fedoc']
}]->(b)
```

---

## Производительность

### Индексация ключей

```sql
-- Создать индекс на key для быстрого поиска
CREATE INDEX idx_nodes_key ON vertices(key);

-- Для рёбер тоже можно индексировать
CREATE INDEX idx_edges_from_key ON edges(from_key);
CREATE INDEX idx_edges_to_key ON edges(to_key);
```

### Кэширование

```python
# Кэш для конвертации key → внутренний ID (если нужен для оптимизации)
_key_to_internal_id_cache = {}

def get_internal_id(key: str) -> int:
    """Получить внутренний ID для оптимизации (опционально)"""
    if key not in _key_to_internal_id_cache:
        result = execute_cypher("MATCH (n {key: $key}) RETURN id(n)", {'key': key})
        _key_to_internal_id_cache[key] = result[0] if result else None
    return _key_to_internal_id_cache[key]
```

---

## Фронтенд изменения

### Старый код
```javascript
const nodeId = node.id || node._id
const nodeKey = node.key || node._key || node.arango_key
```

### Новый код
```javascript
const nodeKey = node.key  // единственный идентификатор
```

### Визуализация
```javascript
// vis-network использует id для узлов
// Можно использовать key как id
const visNode = {
  id: node.key,  // использовать key как id
  label: node.name,
  // ...
}
```

---

## Преимущества подхода "только key"

✅ **Единый идентификатор**: Один вместо двух  
✅ **Самодокументируемость**: По ключу понятно, что это за узел  
✅ **Тип в ключе**: Не нужно хранить `node_type` отдельно  
✅ **Простота API**: Меньше полей в ответах  
✅ **Читаемость**: Понятно в логах, отладке, API  
✅ **Уникальность**: Ключ сам по себе уникален  

---

## Что нужно изменить

1. **БД**: Использовать `key` как первичный идентификатор
2. **Рёбра**: Хранить `from_key` и `to_key` вместо `from_id` и `to_id`
3. **API**: Убрать `id` из ответов, использовать только `key`
4. **Фронтенд**: Использовать `key` как идентификатор узла
5. **Визуализация**: Использовать `key` как `id` в vis-network

---

## Итоговая структура

### Узел
```json
{
  "key": "a.c.project",
  "name": "Проект",
  "properties": {...}
}
```

### Ребро
```json
{
  "id": 123,  // внутренний ID ребра (для визуализации)
  "from": "a.c.project",
  "to": "a.t.python",
  "type": "uses",
  "projects": ["fedoc"]
}
```

---

**Дата создания**: 2025-11-05  
**Автор**: Александр  
**Версия**: 1.0

